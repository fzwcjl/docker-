### vuex的store模板
```
import Vue from 'vue'
import Vuex from 'vuex'
import storage from 'store'
import { login, getInfo, logout } from '@/api/login'
import { welcome } from '@/utils/util'
import { asyncRouterMap as routerConfig } from '@/config/router.config'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    name: '',
    avatar: '',
    routers: [],
    info: {}
  },
  mutations: {
    SET_TOKEN: (state, token) => { // 传参写法，是不是 mutations 方法的第一个参数是默认的，不用调用方传，第一个参数只能是state
      state.token = token
    },
    SET_NAME: (state, { name, avatar }) => { // 传参写法，是不是 mutations 方法的第一个参数是默认的，不用调用方传，第一个参数只能是state
      state.name = name
      state.avatar = avatar
    },
    SET_ROLES: (state, roles) => { // 传参写法，是不是 mutations 方法的第一个参数是默认的，不用调用方传，第一个参数只能是state
      state.roles = roles
    }
  },

  actions: {
    Login ({ commit }, userInfo) { // 传参写法，是不是 actions 方法的第一个参数是默认的，不用调用方传，第一个参数可以包含 commit，state
      return new Promise((resolve, reject) => { // new Promise的参数写法，是不是actions的每个方法都要返回 new Promise
        login(userInfo).then(response => {
          storage.set('ACCESS_TOKEN', response.result.token, 7 * 24 * 60 * 60 * 1000)
          commit('SET_TOKEN', response.result.token)
          resolve() // 无论是否有参数返回，都要写 resolve() 吗，即使 resolve() 是空方法
        }).catch(error => {
          reject(error) // 抛出异常的写法
        })
      })
    },

    GetInfo ({ commit }) { // 传参写法，是不是 actions 方法的第一个参数是默认的，不用调用方传，第一个参数可以包含 commit，state
      return new Promise((resolve, reject) => { // new Promise的参数写法，是不是actions的每个方法都要返回 new Promise
        getInfo().then(response => {
          const result = response.result
          if (result.role && result.role.permissions.length > 0) {
            const role = result.role
            commit('SET_ROLES', result.role)
          } else {
            reject(new Error('getInfo: roles must be a non-null array !')) // 抛出异常的写法
          }
          commit('SET_NAME', { name: result.name, avatar: result.avatar }) // commit 方法多个参数
          resolve(response)
        }).catch(error => {
          reject(error) // 抛出异常的写法
        })
      })
    },

    Logout ({ commit, state }) { // 传参写法，是不是 actions 方法的第一个参数是默认的，不用调用方传，第一个参数可以包含 commit，state
      return new Promise((resolve) => { // new Promise的参数写法，是不是actions的每个方法都要返回 new Promise
        logout(state.token).then(() => {
          resolve() // 无论是否有参数返回，都要写 resolve() 吗，即使 resolve() 是空方法
        }).catch(() => {
          resolve() // 无论是否有参数返回，都要写 resolve() 吗，即使 resolve() 是空方法
        }).finally(() => {
          commit('SET_TOKEN', '')
          commit('SET_ROLES', [])
          storage.remove('ACCESS_TOKEN')
        })
      })
    }
  },
  getters: {
    avatar: state => state.avatar,
    nickname: state => state.name,
    welcome: state => state.welcome,
    userInfo: state => state.info,
    routers: state => state.routers
  }
})

```

### request.js 工具类
```
import axios from 'axios'
import store from '@/store'
import storage from 'store'
import notification from 'ant-design-vue/es/notification'
import { VueAxios } from './axios'

// 创建 axios 实例
const request = axios.create({
  // API 请求的默认前缀
  baseURL: process.env.VUE_APP_API_BASE_URL,
  checkTokenExists: true,
  timeout: 6000, // 请求超时时间
  jumpLoginPageWhen401: true, // http为401时，默认跳转到登录页面重新登录
  headers: {
    'Content-Type': 'application/json;charset=UTF-8'
  }
})

// 异常拦截处理器
const errorHandler = (error) => {
  if (error.response) {
    const data = error.response.data
    if (error.response.status === 403) {
      notification.error({
        message: 'Forbidden',
        description: data.message
      })
    }
    if (error.response.status === 401 && !(data.result && data.result.isLogin)) {
      notification.error({
        message: 'Unauthorized',
        description: 'Authorization verification failed'
      })
      // error.config.jumpLoginPageWhen401 为true时，才重定向
      if (error.config.jumpLoginPageWhen401 === true) {
        store.commit('SET_TOKEN', '')
        store.commit('SET_ROLES', [])
        storage.remove('ACCESS_TOKEN')
        window.location.reload()
      }
    }
  }
  return Promise.reject(error)
}

// request interceptor
request.interceptors.request.use(config => {
  debugger
  const token = storage.get('Access-Token')
  // 如果 token 存在
  // 让每个请求携带自定义 token 请根据实际情况自行修改
  if (token) {
    config.headers['Access-Token'] = token
  } else {
    if (config.checkTokenExists) {
      notification.error({
        message: 'Unauthorized',
        description: 'Authorization verification failed'
      })
      window.location.reload()
    }
  }
  return config
}, errorHandler)

// response interceptor
request.interceptors.response.use((response) => {
  /**
  const url = response.config.url
  const method = response.config.method
  const params = response.config.params
  console.log(method + ' ' + url + ' ' + JSON.stringify(params) + ' ' + JSON.stringify(response.data))
   */
  return response.data
}, errorHandler)

const installer = {
  vm: {},
  install (Vue) {
    Vue.use(VueAxios, request)
  }
}

export default request

export {
  installer as VueAxios,
  request as axios
}

```

### VueAxios.js 文件模板
```
export const VueAxios = {
  vm: {},
  // eslint-disable-next-line no-unused-vars
  install (Vue, instance) {
    if (this.installed) {
      return
    }
    this.installed = true

    if (!instance) {
      // eslint-disable-next-line no-console
      console.error('You have to install axios')
      return
    }

    Vue.axios = instance

    Object.defineProperties(Vue.prototype, {
      axios: {
        get: function get () {
          return instance
        }
      },
      $http: {
        get: function get () {
          return instance
        }
      }
    })
  }
}

```